// ----------------------- memory_ports.ice -----------
// @sylefeb - Silice standard library
// Memory port interfaces
// 2020-09-03

// single port BRAM

interface bram_port {
  output! addr,
  output! wenable,
  input   rdata,
  output! wdata,
}

// single port BROM

interface brom_port {
  output! addr,
  input   rdata,
}

// dual port BRAM

interface dualport_bram_port0 {
  output! addr0,
  output! wenable0,
  input   rdata0,
  output! wdata0,
}

interface dualport_bram_port1 {
  output! addr1,
  output! wenable1,
  input   rdata1,
  output! wdata1,
}

interface dualport_bram_ports {
  output! addr0,
  output! wenable0,
  input   rdata0,
  output! wdata0,
  output! addr1,
  output! wenable1,
  input   rdata1,
  output! wdata1,
}

// simple dual port BRAM

interface simple_dualport_bram_port0 {
  output! addr0,
  input   rdata0,
}

interface simple_dualport_bram_port1 {
  output! addr1,
  output! wenable1,
  output! wdata1,
}

// ----------------------- end of memory_ports.ice ----


// integer division
// A more standard division, compact, 1 cycle per bit
// see also https://projectf.io/posts/division-in-verilog/
// define: div_width    for the division bit width
// define: div_unsigned if unsigned, for a more compact result



algorithm div16(
  input  int16 inum,
  input  int16 iden,
  output int16 ret = 0)
{
  uint16 ac = uninitialized;
  uint16 diff <:: ac - den;
  
  uint5 i = 0;
  
  uint16 num  <:: inum;
  uint16 den  <:: iden;

  ac  = {{15{1b0}},num[15,1]};
  ret = {num[0,15],1b0};
  while (i != 16) {
    if (diff[15,1] == 0) { // positive
      ac  = {diff[0,15],ret[15,1]};
      ret = {ret [0,15],1b1};
    } else {
      ac  = {ac  [0,15],ret[15,1]};
      ret = {ret [0,15],1b0};
    }
    i = i + 1;
  }
}


algorithm main(output uint8 leds)
{
  int16  num    = 20043;
  int16  den    = 41;
  int16  result = 0;
  
  div16 div0;
  
  (result) <- div0 <- (num,den);

  __display("%d / %d = %d",num,den,result);  

  leds = result[0,8];

}

