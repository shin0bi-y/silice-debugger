// ----------------------- memory_ports.ice -----------
// @sylefeb - Silice standard library
// Memory port interfaces
// 2020-09-03

// single port BRAM

interface bram_port {
  output! addr,
  output! wenable,
  input   rdata,
  output! wdata,
}

// single port BROM

interface brom_port {
  output! addr,
  input   rdata,
}

// dual port BRAM

interface dualport_bram_port0 {
  output! addr0,
  output! wenable0,
  input   rdata0,
  output! wdata0,
}

interface dualport_bram_port1 {
  output! addr1,
  output! wenable1,
  input   rdata1,
  output! wdata1,
}

interface dualport_bram_ports {
  output! addr0,
  output! wenable0,
  input   rdata0,
  output! wdata0,
  output! addr1,
  output! wenable1,
  input   rdata1,
  output! wdata1,
}

// simple dual port BRAM

interface simple_dualport_bram_port0 {
  output! addr0,
  input   rdata0,
}

interface simple_dualport_bram_port1 {
  output! addr1,
  output! wenable1,
  output! wdata1,
}

// ----------------------- end of memory_ports.ice ----


// integer division
// Sylvain Lefebvre; simple parallel division; 2019-10-09
// any width version; see divint.ice for more info

// Returns largest positive/negative int on div by zero
//
// == Requires ==
// div_width to be set to the desired bitwidth.
// for div_width = W the algorithm is named divW,
// e.g. div_width = 16 produces algorithm div16
//
// == Options ==
// div_unsigned : unsigned only
// div_shrink   : allows to reduce size at the expense of perf.
//    0 => default, use all stages
//    1 => one stage every two
//    2 => one stage every four
// ...
// at worst the algorithm becomes a loop adding
// den until it exceed num, resulting in worst performance
// but smallest synthesized size



// use pre-processor to generate all comparators
algorithm mul_cmp16_0(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 0);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_1(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 1);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_2(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 2);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_3(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 3);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_4(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 4);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_5(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 5);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_6(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 6);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_7(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 7);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_8(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 8);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_9(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 9);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_10(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 10);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_11(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 11);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_12(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 12);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_13(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 13);
    beq = (nk > den);
  }
}
algorithm mul_cmp16_14(
   input   uint16 num,
   input   uint16 den,
   output! uint1 beq)
<autorun>   
{
  uint17 nk = 0;
  always {
    nk  = (num >> 14);
    beq = (nk > den);
  }
}

// division algorithm
algorithm div16(
  input  int16 inum,
  input  int16 iden,
  output int16 ret)
{
  uint1 r0 = 0;
  uint1 r1 = 0;
  uint1 r2 = 0;
  uint1 r3 = 0;
  uint1 r4 = 0;
  uint1 r5 = 0;
  uint1 r6 = 0;
  uint1 r7 = 0;
  uint1 r8 = 0;
  uint1 r9 = 0;
  uint1 r10 = 0;
  uint1 r11 = 0;
  uint1 r12 = 0;
  uint1 r13 = 0;
  uint1 r14 = 0;

  uint16 reminder = 0;

  uint1 num_neg = 0;
  uint1 den_neg = 0;
  
  uint16 num = 0;
  uint16 den = 0; 

  uint16 concat = 0;

  // instantiate comparators
  mul_cmp16_0 mc0(num <:: reminder, den <:: den, beq :> r0);
  mul_cmp16_1 mc1(num <:: reminder, den <:: den, beq :> r1);
  mul_cmp16_2 mc2(num <:: reminder, den <:: den, beq :> r2);
  mul_cmp16_3 mc3(num <:: reminder, den <:: den, beq :> r3);
  mul_cmp16_4 mc4(num <:: reminder, den <:: den, beq :> r4);
  mul_cmp16_5 mc5(num <:: reminder, den <:: den, beq :> r5);
  mul_cmp16_6 mc6(num <:: reminder, den <:: den, beq :> r6);
  mul_cmp16_7 mc7(num <:: reminder, den <:: den, beq :> r7);
  mul_cmp16_8 mc8(num <:: reminder, den <:: den, beq :> r8);
  mul_cmp16_9 mc9(num <:: reminder, den <:: den, beq :> r9);
  mul_cmp16_10 mc10(num <:: reminder, den <:: den, beq :> r10);
  mul_cmp16_11 mc11(num <:: reminder, den <:: den, beq :> r11);
  mul_cmp16_12 mc12(num <:: reminder, den <:: den, beq :> r12);
  mul_cmp16_13 mc13(num <:: reminder, den <:: den, beq :> r13);
  mul_cmp16_14 mc14(num <:: reminder, den <:: den, beq :> r14);

  // deal with sign (den)
  den = iden;

  // deal with sign (num)
  num = inum;


  // early exit on trivial cases
  if (den > num) {
    ret = 0;
    goto done;
  }
  if (den == num) {
    ret = 1;
    goto done;
  }
  if (den == 0) {
    // div by zero, returns largest positive/negative
    if (num_neg ^ den_neg) {
      ret = 16b1111111111111111;
    } else {
      ret = 16b0111111111111111;
    }
    goto done;
  }

  reminder = num;
  ret      = 0;

  while (reminder >= den) {
  
    // perform assignment based on occurring case
    
    // produce a vector from the comparators
    // it has a one-hot pattern like 0...010...0
    concat = {!r14&&r13,!r13&&r12,!r12&&r11,!r11&&r10,!r10&&r9,!r9&&r8,!r8&&r7,!r7&&r6,!r6&&r5,!r5&&r4,!r4&&r3,!r3&&r2,!r2&&r1,!r1&&r0,1b0};
    // switch base on this number (NOTE: could be a onehot switch)
    switch(concat) {
      case 16b1000000000000000: {
        ret      = ret      + (1<<14);
        reminder = reminder - (den << 14);
      }
      case 16b0100000000000000: {
        ret      = ret      + (1<<13);
        reminder = reminder - (den << 13);
      }
      case 16b0010000000000000: {
        ret      = ret      + (1<<12);
        reminder = reminder - (den << 12);
      }
      case 16b0001000000000000: {
        ret      = ret      + (1<<11);
        reminder = reminder - (den << 11);
      }
      case 16b0000100000000000: {
        ret      = ret      + (1<<10);
        reminder = reminder - (den << 10);
      }
      case 16b0000010000000000: {
        ret      = ret      + (1<<9);
        reminder = reminder - (den << 9);
      }
      case 16b0000001000000000: {
        ret      = ret      + (1<<8);
        reminder = reminder - (den << 8);
      }
      case 16b0000000100000000: {
        ret      = ret      + (1<<7);
        reminder = reminder - (den << 7);
      }
      case 16b0000000010000000: {
        ret      = ret      + (1<<6);
        reminder = reminder - (den << 6);
      }
      case 16b0000000001000000: {
        ret      = ret      + (1<<5);
        reminder = reminder - (den << 5);
      }
      case 16b0000000000100000: {
        ret      = ret      + (1<<4);
        reminder = reminder - (den << 4);
      }
      case 16b0000000000010000: {
        ret      = ret      + (1<<3);
        reminder = reminder - (den << 3);
      }
      case 16b0000000000001000: {
        ret      = ret      + (1<<2);
        reminder = reminder - (den << 2);
      }
      case 16b0000000000000100: {
        ret      = ret      + (1<<1);
        reminder = reminder - (den << 1);
      }
      case 16b0000000000000010: {
        ret      = ret      + (1<<0);
        reminder = reminder - (den << 0);
      }
// last case where 'concat' becomes all 0s
      case 16b0000000000000000: {
        ret      = ret      + (1<<0);
        reminder = reminder - (den << 0);
      }
      default: {
        // should never happen
      }
    }
  }

done:


}


algorithm main(output uint8 leds)
{
  int16  dividend = 20043;
  int16  divisor  = 817;
  int16  result   = 0;
  
  div16 div0;
  
  (result) <- div0 <- (dividend,divisor);

  __display("%d / %d = %d",dividend,divisor,result);  

  leds = result[0,8];
}

